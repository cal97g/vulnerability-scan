import typing
import logging

import abc import ABC

import requests

log = logging.getLogger(__name__)

class QualifierProps:
    has_https: bool
    has_http: bool
    tls_ver: typing.Union[str, None]
    webserver: typing.Union[str, None]

    def to_dict(self) -> typing.Dict:
        return {
            "has_https": self.has_https
            "has_http": self.has_http
            "tls_ver": self.tls_ver
            "webserver": self.webserver
        }

    @classmethod
    def from_dict(cls, **kwargs) -> QualifierProps
        return cls(**kwargs)


QFP = QualifierProps

class PayloadProviderProps:
    url: str
    http_method: str

PPP = PayloadProviderProps

class ExploitDefinition():
    def __init__(self, exploit_identifier: str, steps: typing.List[ExploitStep]):

        if not steps:
            raise ValueError("Must provide list of ExploitSteps")

        self.identifier = identifier
        self.steps = steps

    def __call__(self, url: str) -> bool:
        """
        Executes provided steps, returns boolean based on result.
        """

        success = False

        for i, step in enumerate(self.steps):
            if step.execute():
                success = True
                log.info("{}-{} ".format(self.identifier, step.identifier))
                continue
            else:
                success = False
                log.info("{}-{} ".format(self.identifier, step.identifier))
                break

        return success

class ExploitStep(ABC):
    def __init__(self,
        http_method: str,
        qualifier_props: QualifierProps,
        payload_provider_props: PayloadProviderProps,
        identifier: str
    ):
        self.identifier = identifier
        self._http_method = http_method
        self._qualifier_props = qualifier_props
        self._payload_provider_props = payload_provider_props

    @abstractmethod
    def qualify(self, props: QualifierProps) -> bool:
        pass

    @abstractmethod
    def payload(self, props: PayloadProviderProps) -> typing.Dict:
        """
        a dictionary unpacked directly into requests method function

        eg returning {"url": "https://google.com", "headers": {"name": "dave"}} would result in the effective
        code:

        requests.<method>(url="https://google.com", headers={"name": dave})
        """
        pass

    @abstractmethod
    def vulnerable(self, response: requests.Response) -> bool:
        pass

    def execute(self) -> bool:
        """
        Executes the request and returns
        """
        if self.qualify(self._qualifier_props):
            payload = self.payload(self._payload_provider_props)
            result = getattr(requests, self._http_method.lower())(**payload)
            return self.vulnerable(result)

        return False
